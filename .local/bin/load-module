#!/usr/bin/env python3

import os
import subprocess
import sys
from pathlib import Path
from shutil import Error, copy2, which

import yaml


# install packages function
def install_packages(name, packages):
    """
    Installs the specified packages on the system with pacman/pacaur.

    :param name: Name of the module.
    :param packages: List of packages to be installed.
    """

    print(f'[{name}] Installing packages...')

    # TODO: detect distro and set install command based on that
    # use pacaur if installed, otherwise use pacman
    command_builder = ['pacaur'] if which('pacaur') is not None else ['sudo', 'pacman']

    # add args and packages to the command
    command_builder.append('-S')
    command_builder.append('--quiet')
    command_builder.append('--noconfirm')
    command_builder.append('--noprogressbar')
    command_builder += packages

    # run the command
    print(f'[{name}] {" ".join(command_builder)}')

    with subprocess.Popen(command_builder, stdout=subprocess.PIPE) as command:
        # print each line to stdout as it becomes available
        for line in command.stdout:
            print(f'[{name}] ' + line.decode('UTF-8'))

        # make sure the command has completed before returning the status
        command.wait()

        # return the success
        return command.returncode == 0

# install npm packages function
def install_npm(name, packages):
    """
    Installs npm packages to the system.

    :param name: Name of the module.
    :param packages: List of npm packages.
    """

    print(f'[{name}] Installing npm packages...')

    # set up the empty command
    command_builder = []

    # use yarn if installed, otherwise use npm
    # TODO: use find way to install NPM to ~/.local/bin, env variable for zsh maybe
    if which('yarn') is not None:
        command_builder += ['yarn', 'global', 'add']
    else:
        command_builder += ['npm', 'install', '--global']

    # add packages to the command
    command_builder += packages

    # run the command
    print(f'[{name}] {" ".join(command_builder)}')

    with subprocess.Popen(command_builder, stdout=subprocess.PIPE) as command:
        # print each line to stdout as it becomes available
        for line in command.stdout:
            print(f'[{name}] ' + line.decode('UTF-8'))

        # make sure the command has completed before returning the status
        command.wait()

        # return the success
        return command.returncode == 0

# install pip packages function
def install_pip(name, packages):
    """
    Installs pip modules to the system.

    :param name: Name of the module.
    :param packages: List of pip packages.
    """

    print(f'[{name}] Installing pip packages...')

    # build the install command
    command_builder = ['pip', 'install']

    # add packages to the command
    command_builder += packages

    # run the command
    print(f'[{name}] {" ".join(command_builder)}')

    with subprocess.Popen(command_builder, stdout=subprocess.PIPE) as command:
        # print each line to stdout as it becomes available
        for line in command.stdout:
            print(f'[{name}] ' + line.decode('UTF-8'))

        # make sure the command has completed before returning the status
        command.wait()

        # return the success
        return command.returncode == 0

# install cargo packages function
def install_cargo(name, packages):
    """
    Installs cargo modules to the system.

    :param name: Name of the module.
    :param packages: List of cargo packages.
    """

    print(f'[{name}] Installing cargo packages...')

    # build the install command
    command_builder = ['cargo', 'install']

    # add packages to the command
    command_builder += packages

    # run the command
    print(f'[{name}] {" ".join(command_builder)}')

    with subprocess.Popen(command_builder, stdout=subprocess.PIPE) as command:
        # print each line to stdout as it becomes available
        for line in command.stdout:
            print(f'[{name}] ' + line.decode('UTF-8'))

        # make sure the command has completed before returning the status
        command.wait()

        # return the success
        return command.returncode == 0

# copy resources to their destinations
def copy_resources(name, resources, resource_path):
    """
    Copies resources from the specified path to the configured destination.

    :param name: Name of the module.
    :param resources: List of file:destination pairs for resources.
    :param resource_path: Where to find the resource files.
    """

    print(f'[{name}] Copying resources...')

    # copy each file
    for res in resources:
        try:
            # expand the paths to actually refer to the files
            source = resource_path + res['file']
            dest = os.path.expanduser(res['dest'])
            dest_dir = os.path.dirname(dest)

            # create directory if it doesn't already exist
            if not os.path.isdir(dest_dir):
                os.makedirs(dest_dir)

            # do the copying
            copy2(source, dest)
        except Error as err:
            filename = res['file']

            print(err)
            print(f'[{name}] Something went wrong copying {filename}, skipping.')

# run the setup commands
def run_commands(name, commands, scripts_path):
    """
    Run specified commands with the system shell.

    :param name: Name of the module.
    :param commands: List of command to run.
    :param scripts_path: Path to find scripts.
    """

    print(f'[{name}] Running commands...')

    # turn the commands into lists and put them all in a new lsit
    command_list = [ cmd.split() for cmd in commands ]

    # run each command
    for command_builder in command_list:
        # if the command is a file in the scripts directory, assume it's a script
        script_file = scripts_path + command_builder[0]
        if os.path.isfile(script_file):
            # make sure it's executable
            subprocess.run(['chmod', '+x', script_file], check=False)
            # set the command to be the absolute path to the file
            command_builder[0] = script_file

        with subprocess.Popen(command_builder, stdout=subprocess.PIPE) as command:
            # print each line to stdout as it becomes available
            for line in command.stdout:
                print(f'[{name}] ' + line.decode('UTF-8'))

            # make sure the command has completed before returning the status
            command.wait()

# pretty much all the main logic
def main():
    """Installs a pre-configured module, as specified by the YAML file."""

    component_path = str(Path.home()) + '/.local/dotfiles/components/'
    resource_path = component_path + 'resources/'
    scripts_path = resource_path + 'scripts/'

    # get user-specified modules
    modules = sys.argv[1:]

    # load the base module if it's empty
    if len(modules) < 1:
        modules.append('base')

    # loop through the modules load each one
    for module in modules:
        file = Path(component_path + module + '.yaml')

        # make sure the file exists
        if not file.is_file():
            print(f'There is no module located at {file}.')
            continue

        # load the data from the yaml file
        with open(file, 'r') as file:
            data = yaml.safe_load(file)

            # TODO: pull different package list if on different distro?
            # extract important data
            name        = data['name']      if 'name'       in data else 'Unnamed'
            packages    = data['packages']  if 'packages'   in data else []
            npm         = data['npm']       if 'npm'        in data else []
            pip         = data['pip']       if 'pip'        in data else []
            cargo       = data['cargo']     if 'cargo'      in data else []
            commands    = data['commands']  if 'commands'   in data else []
            resources   = data['resources'] if 'resources'  in data else []

            print(f'Loading Module: {name}...')

            # install packages if the list isn't empty
            if len(packages):
                if not install_packages(name, packages):
                    print(f'[{name}] Package installing failed, skipping module...')
                    continue

                # report success
                print(f'[{name}] Packages installed successfully!')

            # install npm packages if any
            if len(npm):
                if not install_npm(name, npm):
                    print(f'[{name}] NPM installing failed, skipping module...')
                    continue

                # report success
                print(f'[{name}] NPM packages installed successfully.')

            # install pip packages if any
            if len(pip):
                if not install_pip(name, pip):
                    print(f'[{name}] Pip installing failed, skipping module...')
                    continue

                # report success
                print(f'[{name}] pip packages installed successfully.')

            # install cargo packages if any
            if len(cargo):
                if not install_cargo(name, cargo):
                    print(f'[{name}] Cargo installing failed, skipping module...')
                    continue

                # report success
                print(f'[{name}] Cargo packages installed successfully.')

            # copy resources to their destinations, if any
            if len(resources):
                copy_resources(name, resources, resource_path)

            # run the commands if there are any
            if len(commands):
                run_commands(name, commands, scripts_path)

        # show that the process has completed successfully
        print(f'[{name}] Module installed successfully!')

main()
